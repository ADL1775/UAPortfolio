'''

Script Purpose: Week Nine Assignment 13 - PCAP
Script Version: 1.0 March 2023
Script Author:  Adam Livingston, University of Arizona

Script Revision History:
Version 1.0 March 2023, Python 3.x

Simple PCAP File 3rd Party Library 
to process pcap file contents

To install the Library
pip install pypcapfile 

Written exclusively for Python 3.4.x or above

Overview:

The script ingests a standard PCAP File and creates a passive
asset map based on the observed UNIQUE activity and stores the
resultng map as a serialzed python object.  In addition, an html
file is generated that depicts the observed asset map.

Using the pypcapfile library (already available in the VLE),  along with the sample PCAP Files provided, develop a Python Script that extracts features of each packet. 

For each processed PCAP File generate a report with the following information for each unique connection observed and each Observed Port.

Sample output files have been provided.  Examine those to build your solution.

Submit the following:

1) Your python script

2) The report generated by your script that demonstrates the processing of each PCAP File provided.

'''
# TARGET FILE:
# .\PCAPSamples\MODBUS-TestDataPart1.pcap


# Python Standard Library Module Imports

import sys               # System specifics
import platform          # Platform specifics
import os                # Operating/Filesystem Module
import pickle            # Object serialization
import time              # Basic Time Module
import re                # regular expression library
import string
import operator
from binascii import unhexlify
from time import sleep
# 3rd Party Libraries
from prettytable import PrettyTable   # pip install prettytable
from prettytable import DOUBLE_BORDER
from prettytable import DEFAULT
from pcapfile import savefile
from pcapfile.protocols.linklayer import ethernet
from pcapfile.protocols.network   import ip
from pcapfile.protocols.transport import tcp
from pcapfile.protocols.transport import udp
from tqdm import tqdm


# Script Constants
SCRIPT_NAME    = "Week Nine Assignment 13 - PCAP"
SCRIPT_VERSION = "Version 1.0"
SCRIPT_AUTHOR  = "Author: Adam Livingston"
DEBUG   = True



TBLTYPE_IP = 1
TBLTYPE_PORT = 2
MENU_OPT_SAVE = 3
TBLTYPE_PRINT = 4

tblIp = PrettyTable()

tblPort = PrettyTable()

testTable = PrettyTable()
testTable.title = "IP Observations"
tblIp.title = "IP Observations"
tblPort.title = "PORT Observations"

# Script Constants

packetDict = list()
portDict = list()


totalPackets = 0
percent_ten = 0
percent_quarter = 0
percent_half = 0
percent_threeQ = 0
percent_ninety = 0
percent_ninenine = 0
PROG_COUNT = 0
updateProg = True


# Script Local Functions

''' STUDENT FUNCTIONS '''

def ipData(srcIP, dstIP, transport, srcMAC, dstMAC, srcMFG, dstMFG, srcPort, srcPortName, dstPort, dstPortName, ttl, capHour):
     
    # Get the length of the packet list to find the next index
    newPacketIndex = len(packetDict)
    i = 0
    samePacket = False

    if capHour == -1:
        capHour += 1

    # If this is not the first packet...
    if newPacketIndex != 0:
        ''' 
        IS THERE AN EASIER WAY TO DO THIS?!?!?!?!?!
        '''
        # Iterate through the list 
        # If the dictionary at the list index has all key, value pairs match...
        for eachPacket in packetDict:
            i += 1
            if eachPacket["srcIP"] == srcIP:
                samePacket = True
                if eachPacket["dstIP"] == dstIP:
                    samePacket = True
                    if eachPacket["srcMAC"] == srcMAC:
                        samePacket = True
                        if eachPacket["protocol"] == transport:
                            samePacket = True
                            if eachPacket["dstMAC"] == dstMAC:
                                samePacket = True
                                if eachPacket["srcMFG"] == srcMFG:
                                    samePacket = True 
                                    if eachPacket["dstMFG"] == dstMFG:
                                        samePacket = True
                                        if eachPacket["srcPort"] == srcPort:
                                            samePacket = True
                                            if eachPacket["srcPortName"] == srcPortName:
                                                samePacket = True
                                                if eachPacket["dstPort"] == dstPort:
                                                    samePacket = True
                                                    if eachPacket["dstPortName"] == dstPortName:
                                                        samePacket = True                                                
                                                        if eachPacket["ttl"] == ttl:
                                                            samePacket = True
                                                            if eachPacket["dstMAC"] == dstMAC:
                                                                samePacket = True
                                                                i = i - 1
                                                                getHour(i, capHour)
                                                                break
                                                            else:
                                                                samePacket = False
                                                        else:
                                                            samePacket = False
                                                    else:
                                                        samePacket = False
                                                else:
                                                    samePacket = False
                                            else:
                                                samePacket = False
                                        else:
                                            samePacket = False
                                    else:
                                        samePacket = False
                                else:
                                    samePacket = False
                            else:
                                samePacket = False
                        else:
                            samePacket = False                                                
                    else:
                        samePacket = False
                else:
                    samePacket = False
            else:
                samePacket = False
            
    # If even one key/value pair is different (other than occurrances)...
    # Create a new entry
    if samePacket == False:
        packetDict.append({})
        packetDict[newPacketIndex] = { 
                                  "srcIP": srcIP, 
                                  "dstIP": dstIP, 
                                  "protocol": transport,
                                  "srcMAC": srcMAC,
                                  "dstMAC": dstMAC,
                                  "srcMFG": srcMFG,
                                  "dstMFG": dstMFG,
                                  "srcPort": srcPort,
                                  "srcPortName": srcPortName,
                                  "dstPort": dstPort,
                                  "dstPortName": dstPortName,
                                  "ttl": ttl,
                                  "tot pckts": 0,
                                  "HR-00":0,
                                  "HR-01":0,
                                  "HR-02":0,
                                  "HR-03":0,
                                  "HR-04":0,
                                  "HR-05":0,
                                  "HR-06":0,
                                  "HR-07":0,
                                  "HR-08":0,
                                  "HR-09":0,
                                  "HR-10":0,
                                  "HR-11":0,
                                  "HR-12":0,
                                  "HR-13":0,
                                  "HR-14":0,
                                  "HR-15":0,
                                  "HR-16":0,
                                  "HR-17":0,
                                  "HR-18":0,
                                  "HR-19":0,
                                  "HR-20":0,
                                  "HR-21":0,
                                  "HR-22":0,
                                  "HR-23":0}
    
    
        getHour(newPacketIndex, capHour)
    return

# Function to assign the respective hour count
def getHour(dictIndex, hour):
    thePacket = packetDict[dictIndex]
    strHour = str(hour)

    if len(strHour) == 1:
        strHour = "0" + strHour
    
    strHour = "HR-" + strHour
    
    for key, value in thePacket.items():
        if key == strHour:
            #print(type(value))
            thePacket[key] += 1
            thePacket["tot pckts"] += 1
            return

# For the Port Table
def portData(ipAddr, port, portDesc):
    newPortIndex = len(portDict)
    i = 0
    samePort = False
    
    if newPortIndex != 0:
        for eachPort in portDict:
            samePort = True
            if eachPort["IP"] == ipAddr:
                samePort = True
                if eachPort["Port"] == port:
                    samePort = True
                    if eachPort["PortDesc"] == portDesc:
                        samePort = True
                        break
                    else:
                        samePort = False
                else:
                    samePort = False
            else:
                samePort = False                
    
    if samePort == False:
        portDict.append({})
        portDict[newPortIndex] = {"IP": ipAddr,
                                  "Port": port,
                                  "PortDesc": portDesc}
    return


# Printing the menu options
def printMenu(tableType):
    ipMenuOptions = ["How would you like the ***IP TABLE*** sorted?", "[1] Source IP address", "[2] Destination IP address", "[3] Protocol (ARP, TCP, UDP)", "[4] Source MAC", "[5] Destination MAC", "[5] Destination MAC", "[6] Source port", "[7] Destination port", "[8] Time to live", "[9] Total number of packets", "[0] I don't want to sort the IP table."]
    
    portMenuOptions = ["How would you like the ***PORT TABLE*** Sorted?", "[1] IP Address", "[2] Port", "[3] Port Description", "[0] I don't want to sort the port table."]
    
    print("\n" + "="*60)
    if tableType == TBLTYPE_IP:
        for eachEntry in ipMenuOptions:
            print(eachEntry)
    elif tableType == TBLTYPE_PORT:
        for eachEntry in portMenuOptions:
            print(eachEntry)
    
    elif tableType == TBLTYPE_PRINT:
        print("Would you like to print this table to the console? Y/N")
    
    else:
        print("Would you like to save your tables as a .txt document? Y/N")
        
    print("="*60)

# Menu interaction from user
def menu(tableType):
    typeIp = False
    typePort = False
    
    if tableType == TBLTYPE_IP:
        typeIp = True
    if tableType == TBLTYPE_PORT:
        typePort = True

    
    printMenu(tableType)
    
    while True:
        option = input("\nOption: ")
        option = option.replace(" ", "")
        
        if typePort or typeIp:
            if option.isdigit() != True or len(option) != 1:
                printMenu(tableType)
                print("\nInvalid integer option. Please try again.")
                continue
           
            elif tableType == 2:
                option = int(option)
                if option > 3 and not 0:
                    printMenu(tableType)
                    print("\nInvalid option. Please try again.")
                    continue
                else:
                    option = int(option)
                    break
            else:
                option = int(option)
                break
            
        else:
            if option.lower() == 'n':
                return False
            elif option.lower() =='y':
                return True
            else:
                print("\nInvalid option. Please try again.")
        
    
    if tableType == TBLTYPE_IP:
        if option != 0:
            if option == 1:
                tblIp.sortby = "srcIP"
            elif option == 2:
                tblIp.sortby = "dstIP"
            elif option == 3:
                tblIp.sortby = "protocol"
            elif option == 4:
                tblIp.sortby = "srcMAC"
            elif option == 5:
                tblIp.sortby = "dstMAC"
            elif option == 6:            
                tblIp.sortby = "srcPort" 
            elif option == 7:
                tblIp.sortby = "dstPort"
            elif option == 8:
                tblIp.sortby = "ttl"
            elif option == 9:
                tblIp.sortby = "tot pckts"
            
            tblIp.reversesort = True 
        
    elif tableType == TBLTYPE_PORT:
        if option != 0:
            if option == 1:
                tblPort.sortby = "IP"
                tblPort.reversesort = True
            elif option == 2:
                tblPort.sortby = "Port"
                tblPort.reversesort = False
            elif option == 3:
                tblPort.sortby = "PortDesc"
                tblPort.reversesort = False

    return option


def progressUpdate(pkt_num):      
    global t
    global sliceTime
    curTime = time.time()
    
    if pkt_num == 0:
        #t = tqdm(total=int(totalPackets), unit=" Packets", desc="Progress: ")
        sliceTime = curTime
        
    cutTime = int(curTime) - sliceTime
    
    if cutTime > 2:
        t = tqdm(total=int(totalPackets), unit=" Packets", desc="Progress: ")
        t.update(int(pkt_num))
        sliceTime = curTime

    if pkt_num == totalPackets:
        t.close()
''''''''''''''''''''''''''''''
''' END STUDENT FUNCTIONS '''
''''''''''''''''''''''''''''''






''''''''''''''''''''''''
''' PROVIDED CLASSES '''
''''''''''''''''''''''''
class ETH:
    '''LOOKUP ETH TYPE'''
    def __init__(self):
        self.ethTypes = {}
        
        self.ethTypes[2048]   = "IPv4"
        self.ethTypes[2054]   = "ARP"
        self.ethTypes[34525]  = "IPv6"
        
    def lookup(self, ethType):
        try:
            result = self.ethTypes[ethType]
        except:
            result = "not-supported"
            
        return result

# MAC Address Lookup Class
class MAC:
    ''' OUI TRANSLATION MAC TO MFG'''
    def __init__(self):
        
        # Open the MAC Address OUI Dictionary
        with open('oui.pickle', 'rb') as pickleFile:
            self.macDict = pickle.load(pickleFile)
            
    def lookup(self, macAddress):
        try:
            result = self.macDict[macAddress]
            cc  = result[0]
            oui = result[1]
            return cc+","+oui
        except:
            return "Unknown"
        
# Transport Lookup Class

class TRANSPORT:
    ''' PROTOCOL TO NAME LOOKUP'''
    def __init__(self):
        
        # Open the transport protocol Address OUI Dictionary
        with open('protocol.pickle', 'rb') as pickleFile:
            self.proDict = pickle.load(pickleFile)
    def lookup(self, protocol):
        try:
            result = self.proDict[protocol]
            return result
        except:
            return ["unknown", "unknown", "unknown"]

#PORTS Lookup Class

class PORTS:
    ''' PORT NUMBER TO PORT NAME LOOKUP'''
    def __init__(self):
        
        # Open the MAC Address OUI Dictionary
        with open('ports.pickle', 'rb') as pickleFile:
            self.portDict = pickle.load(pickleFile)
            
    def lookup(self, port, portType):
        try:
            result = self.portDict[(port,portType)]
            return result
        except:
            return "EPH"

''''''''''''''''''''''''
''' PROVIDED CLASSES '''
''''''''''''''''''''''''

if __name__ == '__main__':

    print("\n" + SCRIPT_NAME)
    print(SCRIPT_VERSION)
    print(SCRIPT_AUTHOR + "\n")

    # Create Lookup Objects
    macOBJ  = MAC()
    traOBJ  = TRANSPORT()
    portOBJ = PORTS()
    ethOBJ  = ETH()     
    
    ''' Attempt to open a PCAP '''
    while True:
        targetPCAP = input("Target PCAP File: ")
        if not os.path.isfile(targetPCAP):
            print("Invalid File: Please enter valid path\n")
            continue
        try:
            pcapCapture = open(targetPCAP, 'rb')
            capture = savefile.load_savefile(pcapCapture, layers=0, verbose=False)
            print("PCAP Ready for Processing")
            break
        except:
            # Unable to ingest pcap       
            print("!! Unsupported PCAP File Format !! ")
            continue
    
    path = os.path.basename(targetPCAP)
    fileName = path.replace(".pcap","")
    
    fileSize = os.path.getsize(targetPCAP)
    
    fileSize = fileSize / 1000
    
    giveBar = False
    if fileSize > 10000 and giveBar == False:
        print("\nThis is a big file. Giving you a progress bar...\n")
        giveBar = True    
        sleep(2)
        
    totPackets      = 0
    pktCnt          = 0
    print("Processing...\n")
    # Now process each packet
    for pkt in capture.packets:
        
        if pktCnt == 0:
            totalPackets = len(capture.packets)       
        
        if giveBar == True:
            progressUpdate(pktCnt) 
        
        if pktCnt == totalPackets:
            sleep(1)
        
        pktCnt += 1

        # TARGET FILE:
        # ./PCAPSamples/MODBUS-TestDataPart1.pcap
        # ./PCAPSamples/MODBUS-TestDataPart2.pcap
        # ./PCAPSamples/PCAP-3.pcap
        # ./PCAPSamples/PCAP-1.pcap
        # ./PCAPSamples/ICS1.pcap
        # ./PCAPSamples/BACnet_Host.pcap
        
        # extract the hour the packet was captured
        timeStruct  = time.gmtime(pkt.timestamp)
        capHour     = timeStruct.tm_hour     
        
        
        # Get the raw ethernet frame
        ethFrame = ethernet.Ethernet(pkt.raw())
        
        '''
        Ethernet Header
        0                   1                   2                   3                   4              
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                                      Destination Address                                      |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                                         Source Address                                        |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |           EtherType           |                                                               |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                               +
        |                                                                                               |
        +                                            Payload                                            +
        |                                                                                               |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
        '''
            
        ''' ---- Extract the source mac address ---- '''
        srcMAC          = "".join(map(chr, ethFrame.src))
        srcMACLookup    = srcMAC[0:8].upper()
        # remove the colon seperators
        # note the variable names starting with fld, we will use these later
        srcMACLookup  = re.sub(':','',srcMACLookup) 
        
        # Attempt to lookup the mfg in our lookup table 
        # Country Code and Organization
        srcMFG  = macOBJ.lookup(srcMACLookup)    
        
        ''' Extract the destination mac address ---'''
        dstMAC          = "".join(map(chr, ethFrame.dst))
        dstMACLookup    = dstMAC[0:8].upper()
        # remove the colon seperators
        # note the variable names starting with fld, we will use these later
        dstMACLookup  = re.sub(':','',dstMACLookup) 
        
        # Attempt to lookup the mfg in our lookup table 
        # Country Code and Organization
        dstMFG = macOBJ.lookup(dstMACLookup)     
                
        
        ''' Lookup the Frame Type '''
        frameType = ethOBJ.lookup(ethFrame.type)
        
        #print("====== ETHERNET LAYER =====\n")
        #print("TIMESTAMP:", timeStruct)
        #print(type(timeStruct))
        #print("SRC MAC:  ", srcMAC)
        #print("DST MAC:  ", dstMAC)
        #print("SRC MFG:  ", srcMFG)
        #print("DST MFG:  ", dstMFG)
        #print("FRAME TYP:", frameType)
        #print("="*40,"\n")
        
        ''' Process any IPv4 Frames '''
        
        if frameType == "IPv4":
            '''
            ipV4 Header
            0                   1                   2                   3  
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |Version|  IHL  |Type of Service|          Total Length         |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |         Identification        |Flags|     Fragment Offset     |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |  Time to Live |    Protocol   |        Header Checksum        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |                         Source Address                        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |                      Destination Address                      |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |                    Options                    |    Padding    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
            '''
            
            ''' Extract the payload '''
            ipPacket = ip.IP(unhexlify(ethFrame.payload))
            ttl = ipPacket.ttl
                
            ''' Extract the source and destination ip addresses '''
            srcIP = "".join(map(chr,ipPacket.src))
            dstIP = "".join(map(chr,ipPacket.dst))
            
            
            ''' Extract the protocol in use '''
            protocol = str(ipPacket.p)
            
            ''' Lookup the transport protocol in use '''
            transport = traOBJ.lookup(protocol)[0]
            
            #print("====== IPv4 Transport LAYER =====\n")
            #print("TTL:   ",   ttl)
            #print("SRC-IP:",   srcIP)
            #print("DST-IP:",   dstIP)
            #print("Protocol:", protocol)
            #print("="*40,"\n")
            
            if transport == "TCP":
                
                '''
                TCP HEADER
                0                   1                   2                   3  
                0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |          Source Port          |        Destination Port       |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |                        Sequence Number                        |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |                     Acknowledgment Number                     |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                | Offset|  Res. |     Flags     |             Window            |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |            Checksum           |         Urgent Pointer        |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |                    Options                    |    Padding    |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                '''
                ''' 
                **** YOUR CODE HERE ****
            
                '''                
                tcpPacket = tcp.TCP(unhexlify(ipPacket.payload))
                srcPort = tcpPacket.src_port
                dstPort = tcpPacket.dst_port
                
                # .\PCAPSamples\MODBUS-TestDataPart1.pcap
                srcPortName = portOBJ.lookup(str(srcPort), "TCP")
                dstPortName = portOBJ.lookup(str(dstPort), "TCP")
                
                
                ipData(srcIP, dstIP, transport, srcMAC, dstMAC, srcMFG, dstMFG, srcPort, srcPortName, dstPort, dstPortName, ttl, capHour)
                if srcPortName.lower() != "eph":
                    portData(srcIP, srcPort, srcPortName)
                if dstPortName.lower() != "eph":
                    portData(dstIP, dstPort, dstPortName)               

            elif transport == "UDP":
                '''
                 0                   1                   2                   3  
                 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 |          Source Port          |        Destination Port       |
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 |             Length            |            Checksum           |
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 '''
                ''' 
                **** YOUR CODE HERE ****
            
                '''                   
                udpPacket = udp.UDP(unhexlify(ipPacket.payload))
                srcPort = udpPacket.src_port
                dstPort = udpPacket.dst_port
                
                srcPortName = portOBJ.lookup(str(srcPort), "UDP")
                dstPortName = portOBJ.lookup(str(dstPort), "UDP")                    
                                          
                ipData(srcIP, dstIP, transport, srcMAC, dstMAC, srcMFG, dstMFG, srcPort, srcPortName, dstPort, dstPortName, ttl, capHour)
                
                if srcPortName.lower() != "eph":
                    portData(srcIP, srcPort, srcPortName)
                if dstPortName.lower() != "eph":
                    portData(dstIP, dstPort, dstPortName)
                
            elif transport == "ICMP":
                '''
                 0                   1                   2                   3  
                 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 |      Type     |      Code     |            Checksum           |
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 |                                                               |
                 +                          Message Body                         +
                 |                                                               |
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 '''
                
                ''' 
                **** YOUR CODE HERE ****
            
                '''                  
                srcPortName = portOBJ.lookup(str(srcPort), "ICMP")
                dstPortName = portOBJ.lookup(str(dstPort), "ICMP")                
                
                ipData(srcIP, dstIP, transport, srcMAC, dstMAC, srcMFG, dstMFG, srcPort, srcPortName, dstPort, dstPortName, ttl, capHour)
                
                if srcPortName.lower() != "eph":
                    portData(srcIP, srcPort, srcPortName)
                if dstPortName.lower() != "eph":
                    portData(dstIP, dstPort, dstPortName)
                
        elif frameType == "ARP":
            '''
            0                   1      
            0 1 2 3 4 5 6 7 8 9 0 1 2 3
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |  Dst-MAC  |  Src-MAC  |TYP|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |                           |
            +       Request-Reply       +
            |                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |        PAD        |  CRC  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            '''           
            
            ''' 
            **** YOUR CODE HERE ****
        
            '''  
            
            ipData("", "", "ARP", srcMAC, dstMAC, srcMFG, dstMFG, "", "", "", "", ttl, capHour)                     
        
        else:
            continue

    
    
    # HELP FROM:
    #     https://stackoverflow.com/questions/60577354/creating-a-table-with-prettytable-from-list-of-dictionaries
    # Automatically create columns in prettytable
    ### IP TABLE ###
    columnPacket = packetDict[0]
    for key, value in columnPacket.items():
        tblIp.add_column(key, [])
        
    # Add a row with each value in its respective column from every dictionary in the list
    for eachEntry in packetDict:
        tblIp.add_row([eachEntry.get(key, value) for key, value in eachEntry.items()])

        
    ### PORT TABLE ###
    columnPort = portDict[0]
    for key, value in columnPort.items():
        tblPort.add_column(key, [])
    
    for eachEntry in portDict:
        tblPort.add_row([eachEntry.get(key, value) for key, value in eachEntry.items()])    

    # Set the table styles and alignment    
    tblIp.set_style(DOUBLE_BORDER)
    tblPort.set_style(DOUBLE_BORDER)
    tblIp.align = "l"
    tblPort.align = "l"
    
    # Get user menu input
    menu(TBLTYPE_IP)
    option1Print = menu(TBLTYPE_PRINT)
    menu(TBLTYPE_PORT)
    option2Print = menu(TBLTYPE_PRINT)
    savefile = menu(MENU_OPT_SAVE)    
    
    # Flag to determine the ending print message
    actionTaken = False
    
    # To print table to console
    if option1Print or option2Print:
        print("\n" + "="*60)
        print("NOTE: IPv6 not included.")
        print("="*60)
        print("TOTAL PACKET COUNT: ", pktCnt)
        print("="*60)     
        
        if option1Print == True:
            print(tblIp)
            actionTaken = True
        if option2Print == True:           
            print(tblPort)
            actionTaken = True
    
    # To save the tables as .txt file
    if savefile == True:
        tblIp.set_style(DEFAULT)
        tblPort.set_style(DEFAULT)
        newFileName = "livingstonA_PacketTable_" + fileName + ".txt"
        with open(newFileName, "w") as f:
            f.write("="*60)
            f.write("\nNOTE: IPv6 not included.\n")
            f.write("="*60)
            f.write("\nTOTAL PACKET COUNT: " + str(pktCnt))
            f.write("\n" + "="*60 + "\n\n")
            
            f.write(str(tblIp))
            f.write("\n"*3)
            f.write(str(tblPort))
            f.close()
        
        starCount = len(newFileName) + 18
        
        print("\n\n" + "*"*starCount + f"\n* File saved as {newFileName} *\n" + "*"*starCount)
        actionTaken = True
    
    # If the user decides to not do anything
    if actionTaken == False:
        print("\n\nALERT: No tables printed and no files saved! Ending script now.\n")
    
    print("\n\nScript End")
    
